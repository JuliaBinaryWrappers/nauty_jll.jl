# Autogenerated wrapper script for nauty_jll for aarch64-linux-gnu
export dreadnaut, libnauty, dretodot, geng, planarg, pickg, showg, sumlines, newedgeg, blisstog, catg, linegraphg, biplabg, genrang, NRswitchg, listg, hamheuristic, deledgeg, genspecialg, watercluster2, genquarticg, addedgeg, libnautyS1, labelg, libnautyW0, countg, directg, gentreeg, libnautyS0, shortg, delptg, amtog, libnautyA1, gentourng, genbg, twohamg, genbgL, libnautyL1, converseg, cubhamg, subdivideg, copyg, libnautyL0, ranlabg, dretog, libnautyW1, multig, complg, vcolg, checks6

using GMP_jll
## Global variables
PATH = ""
LIBPATH = ""
LIBPATH_env = "LD_LIBRARY_PATH"
LIBPATH_default = ""

# Relative path to `dreadnaut`
const dreadnaut_splitpath = ["bin", "dreadnaut"]

# This will be filled out by __init__() for all products, as it must be done at runtime
dreadnaut_path = ""

# dreadnaut-specific global declaration
function dreadnaut(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(dreadnaut_path)
    end
end


# Relative path to `libnauty`
const libnauty_splitpath = ["lib", "libnauty.so"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libnauty_path = ""

# libnauty-specific global declaration
# This will be filled out by __init__()
libnauty_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libnauty = "libnauty.so.2"


# Relative path to `dretodot`
const dretodot_splitpath = ["bin", "dretodot"]

# This will be filled out by __init__() for all products, as it must be done at runtime
dretodot_path = ""

# dretodot-specific global declaration
function dretodot(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(dretodot_path)
    end
end


# Relative path to `geng`
const geng_splitpath = ["bin", "geng"]

# This will be filled out by __init__() for all products, as it must be done at runtime
geng_path = ""

# geng-specific global declaration
function geng(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(geng_path)
    end
end


# Relative path to `planarg`
const planarg_splitpath = ["bin", "planarg"]

# This will be filled out by __init__() for all products, as it must be done at runtime
planarg_path = ""

# planarg-specific global declaration
function planarg(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(planarg_path)
    end
end


# Relative path to `pickg`
const pickg_splitpath = ["bin", "pickg"]

# This will be filled out by __init__() for all products, as it must be done at runtime
pickg_path = ""

# pickg-specific global declaration
function pickg(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(pickg_path)
    end
end


# Relative path to `showg`
const showg_splitpath = ["bin", "showg"]

# This will be filled out by __init__() for all products, as it must be done at runtime
showg_path = ""

# showg-specific global declaration
function showg(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(showg_path)
    end
end


# Relative path to `sumlines`
const sumlines_splitpath = ["bin", "sumlines"]

# This will be filled out by __init__() for all products, as it must be done at runtime
sumlines_path = ""

# sumlines-specific global declaration
function sumlines(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(sumlines_path)
    end
end


# Relative path to `newedgeg`
const newedgeg_splitpath = ["bin", "newedgeg"]

# This will be filled out by __init__() for all products, as it must be done at runtime
newedgeg_path = ""

# newedgeg-specific global declaration
function newedgeg(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(newedgeg_path)
    end
end


# Relative path to `blisstog`
const blisstog_splitpath = ["bin", "blisstog"]

# This will be filled out by __init__() for all products, as it must be done at runtime
blisstog_path = ""

# blisstog-specific global declaration
function blisstog(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(blisstog_path)
    end
end


# Relative path to `catg`
const catg_splitpath = ["bin", "catg"]

# This will be filled out by __init__() for all products, as it must be done at runtime
catg_path = ""

# catg-specific global declaration
function catg(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(catg_path)
    end
end


# Relative path to `linegraphg`
const linegraphg_splitpath = ["bin", "linegraphg"]

# This will be filled out by __init__() for all products, as it must be done at runtime
linegraphg_path = ""

# linegraphg-specific global declaration
function linegraphg(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(linegraphg_path)
    end
end


# Relative path to `biplabg`
const biplabg_splitpath = ["bin", "biplabg"]

# This will be filled out by __init__() for all products, as it must be done at runtime
biplabg_path = ""

# biplabg-specific global declaration
function biplabg(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(biplabg_path)
    end
end


# Relative path to `genrang`
const genrang_splitpath = ["bin", "genrang"]

# This will be filled out by __init__() for all products, as it must be done at runtime
genrang_path = ""

# genrang-specific global declaration
function genrang(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(genrang_path)
    end
end


# Relative path to `NRswitchg`
const NRswitchg_splitpath = ["bin", "NRswitchg"]

# This will be filled out by __init__() for all products, as it must be done at runtime
NRswitchg_path = ""

# NRswitchg-specific global declaration
function NRswitchg(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(NRswitchg_path)
    end
end


# Relative path to `listg`
const listg_splitpath = ["bin", "listg"]

# This will be filled out by __init__() for all products, as it must be done at runtime
listg_path = ""

# listg-specific global declaration
function listg(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(listg_path)
    end
end


# Relative path to `hamheuristic`
const hamheuristic_splitpath = ["bin", "hamheuristic"]

# This will be filled out by __init__() for all products, as it must be done at runtime
hamheuristic_path = ""

# hamheuristic-specific global declaration
function hamheuristic(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(hamheuristic_path)
    end
end


# Relative path to `deledgeg`
const deledgeg_splitpath = ["bin", "deledgeg"]

# This will be filled out by __init__() for all products, as it must be done at runtime
deledgeg_path = ""

# deledgeg-specific global declaration
function deledgeg(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(deledgeg_path)
    end
end


# Relative path to `genspecialg`
const genspecialg_splitpath = ["bin", "genspecialg"]

# This will be filled out by __init__() for all products, as it must be done at runtime
genspecialg_path = ""

# genspecialg-specific global declaration
function genspecialg(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(genspecialg_path)
    end
end


# Relative path to `watercluster2`
const watercluster2_splitpath = ["bin", "watercluster2"]

# This will be filled out by __init__() for all products, as it must be done at runtime
watercluster2_path = ""

# watercluster2-specific global declaration
function watercluster2(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(watercluster2_path)
    end
end


# Relative path to `genquarticg`
const genquarticg_splitpath = ["bin", "genquarticg"]

# This will be filled out by __init__() for all products, as it must be done at runtime
genquarticg_path = ""

# genquarticg-specific global declaration
function genquarticg(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(genquarticg_path)
    end
end


# Relative path to `addedgeg`
const addedgeg_splitpath = ["bin", "addedgeg"]

# This will be filled out by __init__() for all products, as it must be done at runtime
addedgeg_path = ""

# addedgeg-specific global declaration
function addedgeg(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(addedgeg_path)
    end
end


# Relative path to `libnautyS1`
const libnautyS1_splitpath = ["lib", "libnautyS1.so"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libnautyS1_path = ""

# libnautyS1-specific global declaration
# This will be filled out by __init__()
libnautyS1_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libnautyS1 = "libnautyS1.so.2"


# Relative path to `labelg`
const labelg_splitpath = ["bin", "labelg"]

# This will be filled out by __init__() for all products, as it must be done at runtime
labelg_path = ""

# labelg-specific global declaration
function labelg(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(labelg_path)
    end
end


# Relative path to `libnautyW0`
const libnautyW0_splitpath = ["lib", "libnautyW0.so"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libnautyW0_path = ""

# libnautyW0-specific global declaration
# This will be filled out by __init__()
libnautyW0_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libnautyW0 = "libnautyW0.so.2"


# Relative path to `countg`
const countg_splitpath = ["bin", "countg"]

# This will be filled out by __init__() for all products, as it must be done at runtime
countg_path = ""

# countg-specific global declaration
function countg(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(countg_path)
    end
end


# Relative path to `directg`
const directg_splitpath = ["bin", "directg"]

# This will be filled out by __init__() for all products, as it must be done at runtime
directg_path = ""

# directg-specific global declaration
function directg(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(directg_path)
    end
end


# Relative path to `gentreeg`
const gentreeg_splitpath = ["bin", "gentreeg"]

# This will be filled out by __init__() for all products, as it must be done at runtime
gentreeg_path = ""

# gentreeg-specific global declaration
function gentreeg(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(gentreeg_path)
    end
end


# Relative path to `libnautyS0`
const libnautyS0_splitpath = ["lib", "libnautyS0.so"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libnautyS0_path = ""

# libnautyS0-specific global declaration
# This will be filled out by __init__()
libnautyS0_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libnautyS0 = "libnautyS0.so.2"


# Relative path to `shortg`
const shortg_splitpath = ["bin", "shortg"]

# This will be filled out by __init__() for all products, as it must be done at runtime
shortg_path = ""

# shortg-specific global declaration
function shortg(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(shortg_path)
    end
end


# Relative path to `delptg`
const delptg_splitpath = ["bin", "delptg"]

# This will be filled out by __init__() for all products, as it must be done at runtime
delptg_path = ""

# delptg-specific global declaration
function delptg(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(delptg_path)
    end
end


# Relative path to `amtog`
const amtog_splitpath = ["bin", "amtog"]

# This will be filled out by __init__() for all products, as it must be done at runtime
amtog_path = ""

# amtog-specific global declaration
function amtog(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(amtog_path)
    end
end


# Relative path to `libnautyA1`
const libnautyA1_splitpath = ["lib", "libnautyA1.so"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libnautyA1_path = ""

# libnautyA1-specific global declaration
# This will be filled out by __init__()
libnautyA1_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libnautyA1 = "libnautyA1.so.2"


# Relative path to `gentourng`
const gentourng_splitpath = ["bin", "gentourng"]

# This will be filled out by __init__() for all products, as it must be done at runtime
gentourng_path = ""

# gentourng-specific global declaration
function gentourng(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(gentourng_path)
    end
end


# Relative path to `genbg`
const genbg_splitpath = ["bin", "genbg"]

# This will be filled out by __init__() for all products, as it must be done at runtime
genbg_path = ""

# genbg-specific global declaration
function genbg(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(genbg_path)
    end
end


# Relative path to `twohamg`
const twohamg_splitpath = ["bin", "twohamg"]

# This will be filled out by __init__() for all products, as it must be done at runtime
twohamg_path = ""

# twohamg-specific global declaration
function twohamg(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(twohamg_path)
    end
end


# Relative path to `genbgL`
const genbgL_splitpath = ["bin", "genbgL"]

# This will be filled out by __init__() for all products, as it must be done at runtime
genbgL_path = ""

# genbgL-specific global declaration
function genbgL(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(genbgL_path)
    end
end


# Relative path to `libnautyL1`
const libnautyL1_splitpath = ["lib", "libnautyL1.so"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libnautyL1_path = ""

# libnautyL1-specific global declaration
# This will be filled out by __init__()
libnautyL1_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libnautyL1 = "libnautyL1.so.2"


# Relative path to `converseg`
const converseg_splitpath = ["bin", "converseg"]

# This will be filled out by __init__() for all products, as it must be done at runtime
converseg_path = ""

# converseg-specific global declaration
function converseg(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(converseg_path)
    end
end


# Relative path to `cubhamg`
const cubhamg_splitpath = ["bin", "cubhamg"]

# This will be filled out by __init__() for all products, as it must be done at runtime
cubhamg_path = ""

# cubhamg-specific global declaration
function cubhamg(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(cubhamg_path)
    end
end


# Relative path to `subdivideg`
const subdivideg_splitpath = ["bin", "subdivideg"]

# This will be filled out by __init__() for all products, as it must be done at runtime
subdivideg_path = ""

# subdivideg-specific global declaration
function subdivideg(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(subdivideg_path)
    end
end


# Relative path to `copyg`
const copyg_splitpath = ["bin", "copyg"]

# This will be filled out by __init__() for all products, as it must be done at runtime
copyg_path = ""

# copyg-specific global declaration
function copyg(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(copyg_path)
    end
end


# Relative path to `libnautyL0`
const libnautyL0_splitpath = ["lib", "libnautyL0.so"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libnautyL0_path = ""

# libnautyL0-specific global declaration
# This will be filled out by __init__()
libnautyL0_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libnautyL0 = "libnautyL0.so.2"


# Relative path to `ranlabg`
const ranlabg_splitpath = ["bin", "ranlabg"]

# This will be filled out by __init__() for all products, as it must be done at runtime
ranlabg_path = ""

# ranlabg-specific global declaration
function ranlabg(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(ranlabg_path)
    end
end


# Relative path to `dretog`
const dretog_splitpath = ["bin", "dretog"]

# This will be filled out by __init__() for all products, as it must be done at runtime
dretog_path = ""

# dretog-specific global declaration
function dretog(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(dretog_path)
    end
end


# Relative path to `libnautyW1`
const libnautyW1_splitpath = ["lib", "libnautyW1.so"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libnautyW1_path = ""

# libnautyW1-specific global declaration
# This will be filled out by __init__()
libnautyW1_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libnautyW1 = "libnautyW1.so.2"


# Relative path to `multig`
const multig_splitpath = ["bin", "multig"]

# This will be filled out by __init__() for all products, as it must be done at runtime
multig_path = ""

# multig-specific global declaration
function multig(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(multig_path)
    end
end


# Relative path to `complg`
const complg_splitpath = ["bin", "complg"]

# This will be filled out by __init__() for all products, as it must be done at runtime
complg_path = ""

# complg-specific global declaration
function complg(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(complg_path)
    end
end


# Relative path to `vcolg`
const vcolg_splitpath = ["bin", "vcolg"]

# This will be filled out by __init__() for all products, as it must be done at runtime
vcolg_path = ""

# vcolg-specific global declaration
function vcolg(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(vcolg_path)
    end
end


# Relative path to `checks6`
const checks6_splitpath = ["bin", "checks6"]

# This will be filled out by __init__() for all products, as it must be done at runtime
checks6_path = ""

# checks6-specific global declaration
function checks6(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(checks6_path)
    end
end


"""
Open all libraries
"""
function __init__()
    global artifact_dir = abspath(artifact"nauty")

    # Initialize PATH and LIBPATH environment variable listings
    global PATH_list, LIBPATH_list
    # We first need to add to LIBPATH_list the libraries provided by Julia
    append!(LIBPATH_list, [joinpath(Sys.BINDIR, Base.LIBDIR, "julia"), joinpath(Sys.BINDIR, Base.LIBDIR)])
    # From the list of our dependencies, generate a tuple of all the PATH and LIBPATH lists,
    # then append them to our own.
    foreach(p -> append!(PATH_list, p), (GMP_jll.PATH_list,))
    foreach(p -> append!(LIBPATH_list, p), (GMP_jll.LIBPATH_list,))

    global dreadnaut_path = normpath(joinpath(artifact_dir, dreadnaut_splitpath...))

    push!(PATH_list, dirname(dreadnaut_path))
    global libnauty_path = normpath(joinpath(artifact_dir, libnauty_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libnauty_handle = dlopen(libnauty_path)
    push!(LIBPATH_list, dirname(libnauty_path))

    global dretodot_path = normpath(joinpath(artifact_dir, dretodot_splitpath...))

    push!(PATH_list, dirname(dretodot_path))
    global geng_path = normpath(joinpath(artifact_dir, geng_splitpath...))

    push!(PATH_list, dirname(geng_path))
    global planarg_path = normpath(joinpath(artifact_dir, planarg_splitpath...))

    push!(PATH_list, dirname(planarg_path))
    global pickg_path = normpath(joinpath(artifact_dir, pickg_splitpath...))

    push!(PATH_list, dirname(pickg_path))
    global showg_path = normpath(joinpath(artifact_dir, showg_splitpath...))

    push!(PATH_list, dirname(showg_path))
    global sumlines_path = normpath(joinpath(artifact_dir, sumlines_splitpath...))

    push!(PATH_list, dirname(sumlines_path))
    global newedgeg_path = normpath(joinpath(artifact_dir, newedgeg_splitpath...))

    push!(PATH_list, dirname(newedgeg_path))
    global blisstog_path = normpath(joinpath(artifact_dir, blisstog_splitpath...))

    push!(PATH_list, dirname(blisstog_path))
    global catg_path = normpath(joinpath(artifact_dir, catg_splitpath...))

    push!(PATH_list, dirname(catg_path))
    global linegraphg_path = normpath(joinpath(artifact_dir, linegraphg_splitpath...))

    push!(PATH_list, dirname(linegraphg_path))
    global biplabg_path = normpath(joinpath(artifact_dir, biplabg_splitpath...))

    push!(PATH_list, dirname(biplabg_path))
    global genrang_path = normpath(joinpath(artifact_dir, genrang_splitpath...))

    push!(PATH_list, dirname(genrang_path))
    global NRswitchg_path = normpath(joinpath(artifact_dir, NRswitchg_splitpath...))

    push!(PATH_list, dirname(NRswitchg_path))
    global listg_path = normpath(joinpath(artifact_dir, listg_splitpath...))

    push!(PATH_list, dirname(listg_path))
    global hamheuristic_path = normpath(joinpath(artifact_dir, hamheuristic_splitpath...))

    push!(PATH_list, dirname(hamheuristic_path))
    global deledgeg_path = normpath(joinpath(artifact_dir, deledgeg_splitpath...))

    push!(PATH_list, dirname(deledgeg_path))
    global genspecialg_path = normpath(joinpath(artifact_dir, genspecialg_splitpath...))

    push!(PATH_list, dirname(genspecialg_path))
    global watercluster2_path = normpath(joinpath(artifact_dir, watercluster2_splitpath...))

    push!(PATH_list, dirname(watercluster2_path))
    global genquarticg_path = normpath(joinpath(artifact_dir, genquarticg_splitpath...))

    push!(PATH_list, dirname(genquarticg_path))
    global addedgeg_path = normpath(joinpath(artifact_dir, addedgeg_splitpath...))

    push!(PATH_list, dirname(addedgeg_path))
    global libnautyS1_path = normpath(joinpath(artifact_dir, libnautyS1_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libnautyS1_handle = dlopen(libnautyS1_path)
    push!(LIBPATH_list, dirname(libnautyS1_path))

    global labelg_path = normpath(joinpath(artifact_dir, labelg_splitpath...))

    push!(PATH_list, dirname(labelg_path))
    global libnautyW0_path = normpath(joinpath(artifact_dir, libnautyW0_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libnautyW0_handle = dlopen(libnautyW0_path)
    push!(LIBPATH_list, dirname(libnautyW0_path))

    global countg_path = normpath(joinpath(artifact_dir, countg_splitpath...))

    push!(PATH_list, dirname(countg_path))
    global directg_path = normpath(joinpath(artifact_dir, directg_splitpath...))

    push!(PATH_list, dirname(directg_path))
    global gentreeg_path = normpath(joinpath(artifact_dir, gentreeg_splitpath...))

    push!(PATH_list, dirname(gentreeg_path))
    global libnautyS0_path = normpath(joinpath(artifact_dir, libnautyS0_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libnautyS0_handle = dlopen(libnautyS0_path)
    push!(LIBPATH_list, dirname(libnautyS0_path))

    global shortg_path = normpath(joinpath(artifact_dir, shortg_splitpath...))

    push!(PATH_list, dirname(shortg_path))
    global delptg_path = normpath(joinpath(artifact_dir, delptg_splitpath...))

    push!(PATH_list, dirname(delptg_path))
    global amtog_path = normpath(joinpath(artifact_dir, amtog_splitpath...))

    push!(PATH_list, dirname(amtog_path))
    global libnautyA1_path = normpath(joinpath(artifact_dir, libnautyA1_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libnautyA1_handle = dlopen(libnautyA1_path)
    push!(LIBPATH_list, dirname(libnautyA1_path))

    global gentourng_path = normpath(joinpath(artifact_dir, gentourng_splitpath...))

    push!(PATH_list, dirname(gentourng_path))
    global genbg_path = normpath(joinpath(artifact_dir, genbg_splitpath...))

    push!(PATH_list, dirname(genbg_path))
    global twohamg_path = normpath(joinpath(artifact_dir, twohamg_splitpath...))

    push!(PATH_list, dirname(twohamg_path))
    global genbgL_path = normpath(joinpath(artifact_dir, genbgL_splitpath...))

    push!(PATH_list, dirname(genbgL_path))
    global libnautyL1_path = normpath(joinpath(artifact_dir, libnautyL1_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libnautyL1_handle = dlopen(libnautyL1_path)
    push!(LIBPATH_list, dirname(libnautyL1_path))

    global converseg_path = normpath(joinpath(artifact_dir, converseg_splitpath...))

    push!(PATH_list, dirname(converseg_path))
    global cubhamg_path = normpath(joinpath(artifact_dir, cubhamg_splitpath...))

    push!(PATH_list, dirname(cubhamg_path))
    global subdivideg_path = normpath(joinpath(artifact_dir, subdivideg_splitpath...))

    push!(PATH_list, dirname(subdivideg_path))
    global copyg_path = normpath(joinpath(artifact_dir, copyg_splitpath...))

    push!(PATH_list, dirname(copyg_path))
    global libnautyL0_path = normpath(joinpath(artifact_dir, libnautyL0_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libnautyL0_handle = dlopen(libnautyL0_path)
    push!(LIBPATH_list, dirname(libnautyL0_path))

    global ranlabg_path = normpath(joinpath(artifact_dir, ranlabg_splitpath...))

    push!(PATH_list, dirname(ranlabg_path))
    global dretog_path = normpath(joinpath(artifact_dir, dretog_splitpath...))

    push!(PATH_list, dirname(dretog_path))
    global libnautyW1_path = normpath(joinpath(artifact_dir, libnautyW1_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libnautyW1_handle = dlopen(libnautyW1_path)
    push!(LIBPATH_list, dirname(libnautyW1_path))

    global multig_path = normpath(joinpath(artifact_dir, multig_splitpath...))

    push!(PATH_list, dirname(multig_path))
    global complg_path = normpath(joinpath(artifact_dir, complg_splitpath...))

    push!(PATH_list, dirname(complg_path))
    global vcolg_path = normpath(joinpath(artifact_dir, vcolg_splitpath...))

    push!(PATH_list, dirname(vcolg_path))
    global checks6_path = normpath(joinpath(artifact_dir, checks6_splitpath...))

    push!(PATH_list, dirname(checks6_path))
    # Filter out duplicate and empty entries in our PATH and LIBPATH entries
    filter!(!isempty, unique!(PATH_list))
    filter!(!isempty, unique!(LIBPATH_list))
    global PATH = join(PATH_list, ':')
    global LIBPATH = join(LIBPATH_list, ':')

    # Add each element of LIBPATH to our DL_LOAD_PATH (necessary on platforms
    # that don't honor our "already opened" trick)
    #for lp in LIBPATH_list
    #    push!(DL_LOAD_PATH, lp)
    #end
end  # __init__()

