# nauty_jll.jl

This is an autogenerated package constructed using [`BinaryBuilder.jl`](https://github.com/JuliaPackaging/BinaryBuilder.jl).

For more details about JLL packages, see `BinaryBuilder.jl` [documentation](https://juliapackaging.github.io/BinaryBuilder.jl/dev/jll/).

## Products

The code bindings within this package are autogenerated from the following `Products` defined within the `build_tarballs.jl` file that generated this package:

```julia
products = [
    ExecutableProduct(["dreadnaut"], :dreadnaut),
    LibraryProduct(["libnauty"], :libnauty),
    ExecutableProduct(["dretodot"], :dretodot),
    ExecutableProduct(["geng"], :geng),
    ExecutableProduct(["planarg"], :planarg),
    ExecutableProduct(["pickg"], :pickg),
    ExecutableProduct(["showg"], :showg),
    ExecutableProduct(["sumlines"], :sumlines),
    ExecutableProduct(["newedgeg"], :newedgeg),
    ExecutableProduct(["blisstog"], :blisstog),
    ExecutableProduct(["catg"], :catg),
    ExecutableProduct(["linegraphg"], :linegraphg),
    ExecutableProduct(["biplabg"], :biplabg),
    ExecutableProduct(["genrang"], :genrang),
    ExecutableProduct(["NRswitchg"], :NRswitchg),
    ExecutableProduct(["listg"], :listg),
    ExecutableProduct(["hamheuristic"], :hamheuristic),
    ExecutableProduct(["deledgeg"], :deledgeg),
    ExecutableProduct(["genspecialg"], :genspecialg),
    ExecutableProduct(["watercluster2"], :watercluster2),
    ExecutableProduct(["genquarticg"], :genquarticg),
    ExecutableProduct(["addedgeg"], :addedgeg),
    LibraryProduct(["libnautyS1"], :libnautyS1),
    ExecutableProduct(["labelg"], :labelg),
    LibraryProduct(["libnautyW0"], :libnautyW0),
    ExecutableProduct(["countg"], :countg),
    ExecutableProduct(["directg"], :directg),
    ExecutableProduct(["gentreeg"], :gentreeg),
    LibraryProduct(["libnautyS0"], :libnautyS0),
    ExecutableProduct(["shortg"], :shortg),
    ExecutableProduct(["delptg"], :delptg),
    ExecutableProduct(["amtog"], :amtog),
    LibraryProduct(["libnautyA1"], :libnautyA1),
    ExecutableProduct(["gentourng"], :gentourng),
    ExecutableProduct(["genbg"], :genbg),
    ExecutableProduct(["twohamg"], :twohamg),
    ExecutableProduct(["genbgL"], :genbgL),
    LibraryProduct(["libnautyL1"], :libnautyL1),
    ExecutableProduct(["converseg"], :converseg),
    ExecutableProduct(["cubhamg"], :cubhamg),
    ExecutableProduct(["subdivideg"], :subdivideg),
    ExecutableProduct(["copyg"], :copyg),
    LibraryProduct(["libnautyL0"], :libnautyL0),
    ExecutableProduct(["ranlabg"], :ranlabg),
    ExecutableProduct(["dretog"], :dretog),
    LibraryProduct(["libnautyW1"], :libnautyW1),
    ExecutableProduct(["multig"], :multig),
    ExecutableProduct(["complg"], :complg),
    ExecutableProduct(["vcolg"], :vcolg),
    ExecutableProduct(["checks6"], :checks6)
]
```

## Usage example

For example purposes, we will assume that the following products were defined in the imaginary package `Example_jll`:

```julia
products = [
    FileProduct("src/data.txt", :data_txt),
    LibraryProduct("libdataproc", :libdataproc),
    ExecutableProduct("mungify", :mungify_exe)
]
```

With such products defined, `Example_jll` would contain `data_txt`, `libdataproc` and `mungify_exe` symbols exported. For `FileProduct` variables, the exported value is a string pointing to the location of the file on-disk.  For `LibraryProduct` variables, it is a string corresponding to the `SONAME` of the desired library (it will have already been `dlopen()`'ed, so typical `ccall()` usage applies), and for `ExecutableProduct` variables, the exported value is a function that can be called to set appropriate environment variables.  Example:

```julia
using Example_jll

# For file products, you can access its file location directly:
data_lines = open(data_txt, "r") do io
    readlines(io)
end

# For library products, you can use the exported variable name in `ccall()` invocations directly
num_chars = ccall((:count_characters, libdataproc), Cint, (Cstring, Cint), data_lines[1], length(data_lines[1]))

# For executable products, you can use the exported variable name as a function that you can call
mungify_exe() do mungify_exe_path
    run(`$mungify_exe_path $num_chars`)
end
```
